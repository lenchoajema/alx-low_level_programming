#include <elf.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

/**
 * string_compare - compare two strings
 * @str1: the first string
 * @str2: the second string
 * @n_bytes: the max number of bytes to compare
 *
 * Return: 0 if the first n_bytes of str1 and str2 are equal, otherwise non-zero
 */
int string_compare(const char *str1, const char *str2, size_t n_bytes) {
    while (n_bytes && *str1 && *str2) {
        if (*str1 != *str2) {
            return (*str1 - *str2);
        }
        --n_bytes;
        ++str1;
        ++str2;
    }
    if (n_bytes == 0) {
        return 0;
    }
    if (*str1) {
        return 1;
    }
    if (*str2) {
        return -1;
    }
    return 0;
}
/**
 * _closefd - close a file descriptor and print an error message if it fails
 * @fd: the file descriptor to close
 */
void _closefd(int fd) {
    int close_retval = close(fd);
    if (close_retval == -1) {
        if (write(STDERR_FILENO, "Error: Can't close file descriptor\n", 35) < 0) {
            exit(EXIT_FAILURE);
        }
        exit(EXIT_FAILURE);
    }
    return;
}

/**
 * _read_file - read from a file and handle errors
 * @fd: the file descriptor to read from
 * @buf: the buffer to write to
 * @count: the number of bytes to read
 */
void _read_file(int fd, char *buf, size_t count) {
    ssize_t ret = read(fd, buf, count);
    if (ret == -1) {
        perror("Error: Can't read from file");
        _close_file(fd);
        exit(98);
    }
    if (ret < (ssize_t)count) {
        fprintf(stderr, "Warning: read %zd bytes instead of %zd\n", ret, count);
    }
}

/**
 * _close_file - close a file descriptor and handle errors
 * @fd: the file descriptor to close
 */
void _close_file(int fd) {
    if (close(fd) == -1) {
        perror("Error: Can't close file descriptor");
        exit(98);
    }
}
/**
 * Print the ELF magic bytes of the given ELF header.
 *
 * @param elf_header - The ELF header.
 */
void print_elf_magic(const unsigned char *elf_header) {
    unsigned int i;

    if (strncmp((const char *) elf_header, ELFMAG, 4) != 0) {
        if (write(STDERR_FILENO, "Error: Not an ELF file\n", 23) < 0) {
            exit(EXIT_FAILURE);
        }
        exit(EXIT_FAILURE);
    }

    printf("ELF Header:\n  Magic:   ");

    for (i = 0; i < 16; ++i) {
        printf("%02x%c", elf_header[i], i < 15 ? ' ' : '\n');
    }
}

/**
 * Print the ELF class (bit mode) of the given ELF header.
 *
 * @param elf_header - The ELF header.
 * @return The bit mode of the ELF (32 or 64).
 */
size_t get_elf_class(const unsigned char* elf_header) {
    const unsigned char elf_class = elf_header[EI_CLASS];

    printf("  %-34s ", "Class:");

    if (elf_class == ELFCLASS32) {
        printf("ELF32\n");
        return 32;
    }

    if (elf_class == ELFCLASS64) {
        printf("ELF64\n");
        return 64;
    }

    printf("<unknown: %x>\n", elf_class);
    return 32;
}

/**
 * Print the ELF data (endianess) of the given ELF header.
 *
 * @param elf_header - The ELF header.
 * @return 1 if big endian, otherwise 0.
 */
int get_elf_data(const unsigned char* elf_header) {
    const unsigned char elf_data = elf_header[EI_DATA];

    printf("  %-34s ", "Data:");

    switch (elf_data) {
        case ELFDATA2LSB:
            printf("2's complement, little endian\n");
            return 0;
        case ELFDATA2MSB:
            printf("2's complement, big endian\n");
            return 1;
        default:
            printf("Invalid data encoding\n");
            return 0;
    }
}

/**
 * Print the ELF version of the given ELF header.
 *
 * @param elf_header - The ELF header.
 */
void print_elf_version(const unsigned char* elf_header) {
    const unsigned char elf_version = elf_header[EI_VERSION];

    printf("  %-34s %u", "Version:", elf_version);

    if (elf_version == EV_CURRENT) {
        printf(" (current)\n");
    } else {
        printf("\n");
    }
}

/**
 * Print the ELF OS/ABI of the given ELF header.
 *
 * @param buffer - The ELF header.
 */
void elf_osabi(const unsigned char* buffer) {
    const unsigned char elf_osabi = buffer[EI_OSABI];
    const char* os_table[19] = {
        "UNIX - System V",
        "UNIX - HP-UX",
        "UNIX - NetBSD",
        "UNIX - GNU",
        "<unknown: 4>",
        "<unknown: 5>",
        "UNIX - Solaris",
        "UNIX - AIX",
        "UNIX - IRIX",
        "UNIX - FreeBSD",
        "UNIX - Tru64",
        "Novell - Modesto",
        "UNIX - OpenBSD",
        "VMS - OpenVMS",
        "HP - Non-Stop Kernel",
        "AROS",
        "FenixOS",
        "Nuxi CloudABI",
        "Stratus Technologies OpenVOS"
    };

    printf("  %-34s ", "OS/ABI:");

    if (elf_osabi < 19) {
        printf("%s\n", os_table[elf_osabi]);
    } else {
        printf("<unknown: %x>\n", elf_osabi);
    }
}

/**
 * Print the ELF ABI version of the given ELF header.
 *
 * @param buffer - The ELF header.
 */
void elf_abi_version(const unsigned char* buffer) {
    printf("  %-34s %u\n", "ABI Version:", buffer[EI_ABIVERSION]);
}

/**
 * Print the ELF type of the given ELF header.
 *
 * @param buffer - The ELF header.
 * @param big_endian - Endianness (1 for big endian, 0 for little endian)
 */
void elf_type(const unsigned char* buffer, int big_endian) {
    const char *type_table[5] = {
        "NONE (No file type)",
        "REL (Relocatable file)",
        "EXEC (Executable file)",
        "DYN (Shared object file)",
        "CORE (Core file)"
    };
    unsigned int type;
    
    printf("  %-34s ", "Type:");
    
    if (big_endian) {
        type = (0x100 * buffer[16]) + buffer[17];
    } else {
        type = (0x100 * buffer[17]) + buffer[16];
    }
    
    if (type < 5) {
        printf("%s\n", type_table[type]);
    } else if (type >= ET_LOOS && type <= ET_HIOS) {
        printf("OS Specific: (%4x)\n", type);
    } else if (type >= ET_LOPROC && type <= ET_HIPROC) {
        printf("Processor Specific: (%4x)\n", type);
    } else {
        printf("<unknown: %x>\n", type);
    }
}

/**
 * print_entry_point_address - print entry point address
 * @buffer: buffer containing the entry point address
 * @bit_mode: bit mode (32 or 64)
 * @big_endian: endianness (big endian if non-zero)
 */
void print_entry_point_address(const unsigned char *buffer, size_t bit_mode, int big_endian) {
    int address_size = bit_mode / 8;
    
    printf("  %-34s 0x", "Entry point address:");
    
    if (big_endian) {
        while (address_size && !(*buffer)) {
            --address_size;
            ++buffer;
        }
        
        printf("%x", *buffer & 0xff);
        
        while (--address_size > 0) {
            printf("%02x", *(++buffer) & 0xff);
        }
    } else {
        buffer += address_size;
        
        while (address_size && !(*(--buffer))) {
            --address_size;
        }
        
        printf("%x", *buffer & 0xff);
        
        while (--address_size > 0) {
            printf("%02x", *(--buffer) & 0xff);
        }
    }
    
    printf("\n");
}

/**
 * main - program entry point
 * @argc: argument count
 * @argv: argument vector
 *
 * Return: Always 0
 */
int main(int argc, const char *argv[]) {
    unsigned char buffer[18];
    unsigned int bit_mode;
    int big_endian;
    int fd;
    
    /* Verify the correct number of arguments */
    if (argc != 2) {
        fprintf(stderr, "Usage: %s elf_filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    /* Open the input file for reading */
    fd = open(argv[1], O_RDONLY);
    if (fd == -1) {
        fprintf(stderr, "Error: Can't read from file\n");
        exit(EXIT_FAILURE);
    }
    
    /* Read the first 18 bytes of the file */
    if (read(fd, buffer, sizeof(buffer)) != sizeof(buffer)) {
        fprintf(stderr, "Error: Unable to read ELF header\n");
        exit(EXIT_FAILURE);
    }
    
    /* Extract ELF header information */
    elf_magic(buffer);
    bit_mode = elf_class(buffer);
    big_endian = elf_data(buffer);
    elf_version(buffer);
    elf_osabi(buffer);
    elf_abivers(buffer);
    elf_type(buffer, big_endian);
    
    /* Move the file pointer to the entry point address */
    if (lseek(fd, 24, SEEK_SET) != 24) {
        fprintf(stderr, "Error: Unable to seek to entry point address\n");
        exit(EXIT_FAILURE);
    }
    if (read(fd, buffer, bit_mode / 8) != bit_mode / 8) {
        fprintf(stderr, "Error: Unable to read entry point address\n");
        exit(EXIT_FAILURE);
    }
    
    /* Display the entry point address */
    print_entry_point_address(buffer, bit_mode, big_endian);
    
    /* Close the input file */
    close(fd);
    
    return (EXIT_SUCCESS);
}

